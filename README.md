# Seven Segment Subway Surfers

## Overview
A fast-paced, endless runner game inspired by Subway Surfers! Built using Verilog for the FPGA Basys3 board, the included seven segment display, and the PMOD JSTK1 module. A joystick will control the player’s input, moving the player character left and right on the seven-segment display. The seven-segment display will also be used to show the player’s score each time the game ends. 


## Gameplay
The display is vertical, with the seven segment display on top and the four buttons on the bottom. The player may move left and right within the boundaries of the 4th digit of the display. That is, they have 3 possible spaces to be at any point in time: left, center, and right. However, attempting to move left from the leftmost space or right from the rightmost space, will result in no movement. Furthermore, the player will continue to dodge obstacles until they crash. Due to the limitations of the seven-segment display, we will show obstacles on the first 3 “digits” of the board while leaving the player character on the 4th digit. Only the player character will be displayed on the 4th digit.
If the player presses the start button, then a random 3 bit number will be generated using an LFSR and is later used to generate an obstacle. Specifically, the number will represent the position of the obstacle to be generated – for example, a number of 101 will represent an obstacle that blocks the left and right positions, but not the center. During each turn, each obstacle will move down a row, with the obstacle on the 3rd digit disappearing. Finally, when the player “crashes” by remaining in the same position as an obstacle on the 3rd digit, the game will end, the display will clear, and will show the player’s final score. 

## Scoring
The player will earn a higher score the longer they survive. As time goes on, the game will get harder, and the player will thus earn points faster. Difficulty scales by making the obstacles move faster over time so it is harder to dodge obstacles. The score will be displayed to the player when they crash using the seven-segment display.

## Implementation
Find our top-level design module in `game.v`. Find our various other modules, including some for the PMOD JSTK adapted from Josh Sackos. 

Below are more detailed descriptions of our implementation: 
Our design was split up into 7 main modules, with 4 supplementary modules handling the joystick PMOD input. Each module handled one main aspect of our project, and this structure made it much easier to make incremental changes, building on our past work effectively.
The top-level module, Game, is mainly used to instantiate each other module and connect them all. It takes input from and sends output to the Basys 3 board and joystick module. It also does some important tasks like setting up clocks to be used in other modules and extracting the joystick data from the Pmod modules.
	The Debouncer module is pretty short, simply turning the analog input from the joystick into two digital button_left and button_right signals. It did this by checking if the x position of the joystick was higher or lower than certain thresholds. This module also debounced the start/reset button.
	The RNG module creates a random number generator using a Linear-Feedback Shift Register (LFSR). This uses “taps,” which are certain bits that are XORed together, to generate a new bit, then shifts all the bits in one direction, outputting the bit shifted out of the register. This creates pseudorandom numbers which is later used to generate obstacle patterns.
	The Obstacles module takes in the random bits generated by the RNG module and creates obstacles to be used in the game. It uses a clock which speeds up as time goes on, making the game harder. When this clock is triggered, it shifts the obstacles down the screen, towards the player. Any obstacle in the bottom row is removed, while the top obstacle must be generated. To do this, it takes in 3 random bits from the RNG (over 3 clock cycles), and fills in the 3 spaces of the obstacle based on these bits. If all 3 are one, the obstacle is made empty, since this would be impossible to pass otherwise. Every other obstacle is empty to make the game more possible to play.
	The Player module takes in the digital signals created by the Debouncer module and updates the player’s position based on them. It represents the player’s position in a 3-bit number, although only one bit will be on at a time (one-hot encoding). Holding the joystick in one direction will only move the player once by storing if the player has already been moved without releasing the joystick.
	The Logic module uses the obstacles’ and player’s positions to calculate if the player has crashed into an obstacle. It does this by doing a bitwise AND between the furthest-down obstacle and the player. If any bit is 1, this means the player and obstacle have collided. In this case, the game ends and the display shows the player their score. This module also keeps track of their score, increasing it continuously. This rate starts at 10 points per second, but increases to 50 points per second if the player stays alive long enough. This compensates for the increasing difficulty and encourages the player to survive.
	Finally, the display module outputs the state of the game to the player through the seven-segment display. If the player has not crashed yet, it will show the current state of the obstacles and player by calling functions turning on the correct segments. If the player has crashed, it will instead display the score they achieved in the game.
	Our design also utilized some modules found online (https://www.instructables.com/How-to-Use-the-PmodJSTK-With-the-Basys3-FPGA/) to process the joystick inputs. These modules—PmodJSTK, spiCtrl, SPImode0, and ClkDiv_66_67kHz—were instantiated by the Game module, and interfaced with the joystick, returning a 40-bit value storing the position of the joystick in the x and y direction, and the states of the two push buttons. The x position of the joystick was extracted, and was used to control the player.

## Final Comments
It was a super fun project. Huge props to my teammate Zachary DeSoto, it was awesome working with you. 
